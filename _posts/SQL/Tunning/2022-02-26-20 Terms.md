---
title:  "MYSQL Structure"
excerpt: ""
categories:
  - SQL_Tunning
last_modified_at: 2021-10-14

toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true

use_math: true
typora-root-url: ../../../../hana-dool.github.io
---

 MYSQL 과 MariaDB
{: .notice--warning}

# [SQL](#link){: .btn .btn--primary}{: .align-center}

> ## Mysql 과 Oracle 은 구조적인 차이를 보인다.

- 이때 기본적으로 데이터가 저장되는 스토리지의 구조 족면에서 큰 차이를 보입니다.
  - 오라클 DB 는 통합된 스토리지 하나를 공유해서 사용하는 방식입니다. 
  - MYSQL 은 물리적인 DB 서버마다 독립적으로 스토리지를 할당해서 구성합니다.

![jpg](/assets/images/Program/62_1.jpg)

- 위 그림처럼 오라클의  경우에는 공유 스토리지를 사용하므로 사용자가 어느 DB 에서 접속해서 SQL 문을 사용하더라도 같은 결과를 출력하거나, 동일한 구문 (Select , insert ..) 를 처리할 수 있습니다.

![jpg](/assets/images/Program/62_2.jpg)

- 만면에 MYSQL 은 곧립적인 스토리지 할당에 기반을 둡니다.
- 보통 마스터 슬레이브 구조가 대부분입니다. 
  - 마스터 노드는 쓰기 / 읽기를 모두 처리 가능 
  - 슬레이브 노드는 읽기 처리만 가능
- 즉 물리적으로 여러대의 MYSQL DB 서버에 접근하더라도, 동일한 구문이 처리되지 않을 수 있습니다. (SELECT , INSERT .... )
  - 또한 DB 서버마다 각자의 역할이 부여될 수 있습니다.

> ## 쿼리 오프로딩

- DB 의 트련젝션에서 Update 트련잭션과 Read 트랜잭션을 분리하여 DB 의 저리량을 증가시켜 성능 항상을 위한 기법입니다. 
  - 쓰기 트렌젝션 : UPDATE , INSERT , DELETE 
  - 읽기 트렌젝션 : SELECT
- 일반적으로 여러개의 DB 로 구성하게 된다면, 마스터 - 슬레이브 구조로 구축하게 되고 여기에서는 에플리케이션을 통해서 쿼리 오프로딩이 적용됩니다. 
  - 즉 마스터 노드에서는 UPDATE , INSERT ,  DELETE 를 수행합니다. 
  - 슬레이브 노드에서는 SELECT 를 수행합니다. 
- 만일 마스터노드에서 SELECT 를 쓰려고 하는 등, 역할에 맞지 않는 작업을 하려고 한다면 에러가 나게 될 것입니다. 
- 그러므로 서버의 구조를 충분히 이해하고 적합한 서버에 접근해 쿼리 튜닝을 하는것은 매우 중요합니다.

> ## 물리 엔진 

- MySQL이라는 DBMS는 데이터를 저장하고, 저장된 데이터를 가공하는 연산을 수행합니다. 
- 그 과정은 우리의 일상 속 겅험과 크게 다르지 않습니다. 이해를 돕고자 푸드코트에서 음식을 주문하는 과정에 빗대어 설명해보겠습니다.

![jpg](/assets/images/Program/63_1.jpg)

- 위 그림에서와 같이 우리는 푸드코트에서 한식을 주문하기로 했다고 합시다.
- 주문울 가는 점원 에계 가서 한식을 주문하고 바용을 결제합니다. 
  - 이때 점원은 주문한 메뉴가 조라 가능한 음식 인지. 재료가 떨어진 음식은 아닌지, 몌뉴만에 기재된 음식인지와 같은 세부 행목을 확인합니 다. 
  - 이후 손님이 주문한 메뉴는 한식 조리실로 전달되어 조리되며 완성된 음식은 점원에계 전달됩니다. 메뉴 주문을 받고 서빙하는 점원은 완성된 음식을 접시에 예패게 담고, 퐃과 악세사려로 플레이팅하여 손넙에게 제공합니다.
- 이치럽 손님의 요구사항은 조리실까지 차례로 전달되며, 조리실에서는 해당 메뉴를 저장된 재료로 요리합니다. 
- 완성된 음식은 접시이 담아 꾸미고, 더러워진 부분은 깨끗이 다아 손범에계 졔 공합니다. 
  - 이러한 일련의 과정은 $\mathrm{SQL}$ 문 요칭에 따라 최종 길과가 출력되기까지의 과정과 크계 다르지 않습니다.

![jpg](/assets/images/Program/63_2.jpg)

- 푸트코드에서 음식을 주문하는 과정과 마찬가지로, 사용자는 $\mathrm{DB}$ 에서 원하는 데이터를 가져 오고자 SQL 문을 실행합니다.
- 실행된 SQL 문은 MySQL 엔진에서 문법 에러가 있는지, DB 에 존재하는 테이블 대상으로 SQL 문을 작성했는지와 같은 세부 사항을 다양한 문법 및 구문 으로 검사합니다(파싱 작업을 하는 파서parser 역할), 
- 이후 사용자가 요청한 데이터를 빠르고 효율적으로 찾아가는 전략적 계획을 수립합니다(옵티마이정pㄹimizer 역할), 이 계회을 토대로 스토리지 엔진에 위치한 데이터까지 찾아간 뒤 해당 데이터를 MySQL 엔진으로 전달합니다.
- MySQL 엔진은 전달된 데이터에서 불펄요한 부분을 필터링 (제거, 변깅)하고 필요한 연산을 수행한 뒤 사용자에게 최종 결과를 알려쥽니다.

> ## 스토리지 엔진 

- (InnoDB, MyISAM, Memory 등) 스토리지 엔진은 사용자가 요칭한 SQL 문을 토대로 DB 에 저장된 디스크나 메모리에서 필요한 데이터를 가져오는 역할을 수행합니다.
  - 이후 해당 데이터를 MySQL 엔진으로 보내즙니다. 
- 스토리지 엔진이 데이터를 저장하는 방식에 따라 각각의 스토리지 엔진을 선택하여 사용할 수 있으며, 펼요하다면 외부에서 스토리지 엔진 설치 파일을 가져와 사용할 수 있습니다.
- 일반적으로는 온라인상의 트랜잭션 발생으로 데이터를 치리하는 OLTP $^{\text {online transaction procesing }}$ 환경이 대다수인 만큼 주로 InnoDB 엔진을 사용합니다. 
- 그 밖에도 대량의 쓰기 트랜잭션이 발생하면 MyISAM 엔진을, 메모리 데이터를 로드하여 빠르게 읽는 효과를 내려면 Memory 엔진을 사용하는 식으로 응용하여 스토리지 엔진을 선택할 수 있습니다.
- 스토리지엔진은 DB에서 데이터를 어떠한 방식으로 저장하고 접근할 것인지에 대한 기능을 제공한다. 
  - 스토리지엔진의 특성에 따라 데이터 접근이 얼마나 빠른지, 얼마나 안정적인지, 트랜잭션 등의 기능을 제공하는지 등의 차이점이 발생한다 

> MyISAM 

- MySQL의 기본 스토리지 엔지으로 데이터 저장에 실제적인 제한이 없고 매우 효율적으로 저장한다. Full-Text 인덱스를 지원하며 특정 인덱스에 대해 메모리 캐쉬를 지원한다. 트랜잭션은 미지원/ 테이블 레벨의 락을 지원 잦은 변경및 삭제에는 좋은 성능이 나오지 못하나 데드락 발생은 예방가능 
- 데이블작업시 특정행을 수정하려고 하면 테이블 전체에 락이 걸려서 다른사람이 작업할수없다. 간단하게 말하면 작업시에 Table-level Lock이 걸리게 된다. 
- 트랜잭션에 대한 지원이 없기때문에 작업도중 문제가 생겨도 이미 db안으로 데이터가 들어감 
- 주로 select 작업이 많은 경우에 사용된다. 

> InnoDB 

- ACID 트랜잭션을 지원하며, MyISAM보다 데이터 저장비율이 낮고, 데이터 로드 속도가 느리다. 특정 데이터와 인덱스에 대해서 메모리 캐쉬를 지원하며 외부티를 지원한다. 데이터 압축이 불가능하고 자동 에러 복구 기능이 있다. 테이블 레벨이 아닌 ROW 레벨의 락을 지원한다. 
- 테이블작업시 작업 시작하면 해당 열만 잠기게 되며 나머지 부분은 다른사용자가 수정 가능 
- 간단하게 말하면 작업시에 Row-level Lock이 걸리게 된다. 
- row-level 이다보니까 insert,update,delete에 대한 속도가 빠르다 
- 주로 데이터 입력 및 수정이 빈번한 높은 퍼포먼스를 요구하는 대용량 사이트에서 적합 

> Cluster (NDB) 

- 트랜잭션을 지원하고 모든 데이터와 인덱스가 메모리에 존재하여 매우 빠른 데이터 로드 속도를 자랑하며 PK 사용시 최상의 속도를 나타낸다. 

> Archive 

-- MySQL 5.0부터 새롭게 도입된 엔진으로 자동적으로 데이터 압축을 지원하며 다른 엔진에 비해 80% 저장공간 절약 효과를 자랑한다. 그리고 가장 빠른 데이터 로드 속도 또한 자랑하지만, INSERT와 SELECT만이 가능하다. 

> Federated 

- MySQL 5.0부터 새롭게 도입된 엔진으로 물리적 데이터베이스에 대한 논리적 데이터베이스를 생성하여 원격 데이터를 컨트롤 할 수 있다. 실행속도는 네트워크 요소에 따라 좌우되면 테이블 정의를 통한 SSL 보안 처리를 한다. 분산 데이터베이스 환경에 사용한다 

> ## MYsql 엔진

- MySQL 엔진은 사용자가 요청한 SQL 문을 념겨받은 뒤 SQL 문법 검사와 적절한 오브젝트 활용 검사를 하고, $\mathrm{SQL}$ 문을 최소 단위로 분리하여 원하는 데이터를 빠르게 찾는 경로를 모 색하는 역할을 수행합니다. 
- 이후 스토리지 엔진으로부터 전달받은 데이터 대상으로 불펄요한 데이터는 제기하기나 가공 및 연산하는 역할을 합니다. 
- 즉, $\mathrm{SQL}$ 문의 시작 및 마무리 단계에 MySQL 엔진이 관여하며, 스토리지 엔진으로부터 필요한 데이터만을 가져오는 핵심 역할을 담당한다고 할 수 있습니다.

# [SQL Process](#link){: .btn .btn--primary}{: .align-center}

> ## SQL 프로세스

- $\mathrm{SQL}$ 문은 의외로 복잡한 과정을 기쳐 결괏값을 출력합니다. 그 복잡한 과정을 살펴보기 전에 [그림 2-3]과 같이 택시 기사에 비유하여 간단히 이해해봅니다. 

> 택시 Example

![jpg](/assets/images/Program/63_3.jpg)

- 서울에서 택시 운전을 하는 $\mathrm{A}$ 씨는 칫 번째 손님을 태었습니다. 탑숭한 손님은 몽골어로 "Бусан руу явцгаая, "라고 요
  구헸으나 무슨 뜻인지 알 수 없어 목적지까지 안내할 수 없었습니다. 
- 다음으로 두 번째 손넘을 태웠습니다. 손님 은 "뉴욕으로 가주세요"라고 요구혔고, $A$ 씨는 어뗜 요구사항인지 이해해보려 했습니다. 그러나 한국에는 뉴목이라는 도시가 없으므로 결국 두 번째 손범도 목적지까지 안내할 수 없었습니다. 
- 마지막으로 태운 손넘은 "부산으로 가주세요"라고 말했습니다. 택시 기 사 $\mathrm{A}$ 씨는 손넘이 원하는 내용을 충분히 이해했고 부산의 위치도 정확히 알고 있었습니다. $\mathrm{A}$ 씨는 짧고 빠른 경로를 선택하여 손넘을 원하는 목적지까지 무사히 안내할 수 있었습니다.

> SQL 에서는?

- $\mathrm{SQL}$ 문을 수행하는 과정 역시 택시 기사 $\mathrm{A}$ 씨가 일상에서 겪은 경험과 크게 다르지 않습니다. 
- 사용자가 $\mathrm{SQL}$ 문을 수행하면, 파서는 $\mathrm{MySQL}$ 이 이해할 수 있는 최소 단위로 구성요소를 분리 하고 해당 구성요소를 트리로 만듭니다. 
  - 트리를 만드는 과정에서는 문법 오류가 있는지 겸토합 니다. 트리의 최소 단위는 $>\langle,=$ 등의 기호나 $\mathrm{SQL}$ 키워드로 분리합니다. 만약 트리에 허용되 지 않는 문법이 포함된다면 에러 발생과 동시에 실행이 종료됩니다.
- 이후 전치리기 (preprocessor) 는 생성된 트리 결과를 토대로, 이미 만들어진 테이블이나 뷰 등으로 구성되지는 않는지, 존재하지 않은 열을 포함하지는 않는지, 조희 권한이 없는 테이블올 조혀 하는지 둥 유효성을 점증합니다.
  - 만약 유효하지 않은 오브젝트가 있기나 권한이 없는 오브젝트 를 호줄하면 바로 에러를 발생하여 사용자에게 표시합니다.
- 다음으로 옵티마이저 opemizer 는 트리를 구성하는 오브젝트의 데이터를 효율적으로 가져오기 위 해 시간은 적게 소요되면서도 비용 효율적인 경로로 데이터를 검색하는 방법에 관한 실행 계회을 수립합니다. 
  - 엔진 실행기 engine exccutor는 이전에 수립된 실행 계획으로 스토리지 엔진을 호 출해 펄요한 데이터를 가져옵니다. 이후 엔진 실행기는 스토리지 엔진을 통해서 가져온 데이터 중 불펄요한 데이터를 펼터링하여 사용자가 원하는 결과를 전달합니다.

![jpg](/assets/images/Program/63_4.jpg)

- 이러한 $\mathrm{SQL}$ 실행 과정에서 핵심 역할을 수행하는 오브젝트는 크게 파서, 전처리기, 옵티마이 저, 엔진 실행기로 구분됩니다. 각 오브젝트를 간단히 정리해보면 다음과 같습니다.

> ## 파서

- 파서는 QL 엔진에 포함되는 오브젝트입니다.
- 사용자가 요청한 SQL 문을 쪼개서, 최소 단위로 분리하고 트리를 만듭니다.
  - 이때 트리를 만들때에 문법 검사를 수행하게 됩니다.

```
SELECT A, B, C FROM OBJ POOL WHERE A = 45 AND ...
```

- 위와 같은 쿼리를 수행하게 되면 아래왁 같이 분해됩니다.

![jpg](/assets/images/Program/63_5.jpg)

> ## 전처리기

- 전치리기 preprocenso는 MySQL 엔진에 해당하는 오브젝트로, 파서에서 생성한 트리를 토대로 $\mathrm{SQL}$ 문에 구조적인 문제가 없는지 파악합니다.
-  $\mathrm{SQL}$ 문에 작성된 테이블, 열, 함수, 뷰와 같은 오브젝트가 실질적으로 이미 생성된 오브젝트인지, 접근 권한은 부여되어 있는지 확인하는 역할을 합니다.

> ## 옵티마이저

- 옵티마이저 optimizer 는 MySQL 의 핵심 엔진 중 하나로, DBMS에서 두뇌라고 불러도 과언 이 아닐 만큼 핵심적인 역할을 수행합니다. 
- 전달된 파서 트리를 토대로 펼요하지 않은 조건은 제기하거나 연산 과정을 단순화합니다. 
  - 나아가 어떤 순서로 테이블에 접근할지, 인덱스를 사용 할지, 사용한다면 어떤 인덱스를 사용할지, 정렬할 때 인덱스를 사용할지 아니면 임시 테이블 temporary table 을 사용할지와 같은 실행 계획을 수립합니다.
- 단, 실행 계획으로 도출할 수 있는 경우의 수가 지나치게 많을 때는 실행 계획을 수립하고 비용 을 산정하여 최적의 실행 계획을 선택하기까지 시간이 오래 걸리는 만큼 모든 실행 계회을 판단하지는 않습니다. 
  - 이는 옵티마이저가 선택한 최적의 실행 계획이 최상의 실행 계획이 아닐 가능성도 있다는 걸 의미합니다.
- 실행 계획을 수립하는 작업 자체만으로도 사용자의 대기 시간과 하드웨어 리소스를 점유하므 로, 시간과 리소스에 제한을 두고 실행 계획을 선정해야 합니다.
  -  이처럼 옵티마이저가 예촉한 모든 실행 계획이 항상 최적의 실행 계회은 아닌 만큼 $\mathrm{MySQL}$ 과 $\mathrm{MariaDB}$ 를 적절히 다루는 우리들의 도움이 필요할 수 있다는 의미입니다.

> ## 엔진 실행기

![jpg](/assets/images/Program/63_5.jpg)

- 엔진 실행기 ${ }^{\text {engine executar }}$ 는 MySQL 엔진과 스토리지 엔진 영역 모두에 걸치는 오브젝트로, 옵티마이저에서 수립한 실행 계획을 참고하여 스토리지 엔진에서 데이터를 가져옵니다. 
- 이후 MySQL 엔진에서는 읽어온 데이터를 정렬하거나 조인하고, 불필요한 데이터는 펼터링 처리하는 추가 직업을 합니다. 
  - 따라서 MySQL 엔진의 부하를 줄이려면 스토리지 엔진에서 가져오는 데이터양을 줄이는 게 매우 증요합니다.

# [DB Object](#link){: .btn .btn--primary}{: .align-center}

> ## DB object terms

- 데이터베이스를 구성하는 요소 중 하나로 오브잭트라 불리는 객체들이 있습니다. 
  - 각 오브젝트의 개넘을 간단히 살펴보겠숩니다.
- 여러분은 아마 웹사이트나 객에서 표 형태의 구조를 많이 접해볐을 것입니다. 예를 들면 다음 [그립 2-5]와 같은 표에서 학번을 비롯해 이름, 생년월일, 연락치, 전공코드 관련 정보가 들어있습니다.

![jpg](/assets/images/Program/63_6.jpg)

- 이와 마찬가지로 2 차원 형태의 관계형 데이터베이스에서 표는 테이블 table, 열은 컬럽column, 행 은 로우 ${ }^{\operatorname{aw}}$ 라는 용어로 사용합니다. 
- 이러한 테이블과 컬럼, 로우에 관해 더 자세히 알아보겠습니다(이 책에서는 편의상 '컬럽'과 '로우'를 각각 '열'과 '행' 으로 표기합니다).

 
