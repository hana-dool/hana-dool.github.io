---
title:  "Thread Management"
excerpt: "스레드 관리"
categories:
  - Operating_System
last_modified_at: 2021-11-25
toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true
author_profile: true

use_math: true
typora-root-url: ../../../../hana-dool.github.io
---

 운영체제에 대해서 알아봅시다.
{: .notice--warning}

# [Thread](#link){: .btn .btn--primary}{: .align-center}

> ## Process and Thread

> process 

- 우리가 어떤 작업을 하기 위하여, 프로세스는 자원을 할당받고, 그것을 제어하게 됩니다. 
  - 이때 두가지 일 (할당과 제어) 을 한다고 생각할 수 있는데요, 이때 제어 부분만 분리하여 생각하는게 바로 쓰레드입니다. 
  - 이러한 쓰레드는 여러개가 있을 수 있습니다. (즉 제어는 여러개가 있을 수 있습니다.)

> Thread

![png](/assets/images/Program/16_1.png)

- 리소스는 오른쪽과 같이 프로세스가 사용하는 메모리 공간은 힙 공간에 잡히게 됩니다.
- 프로세스는 왼쪽 그림과 같이 다양한것들을 제어하게 됩니다.
  - 지역 데이터 : block 안에서만 유의미한 데이터 (제어를 위해 사용)
  - 스택영역에 저장됨
- 제어 부분만 떼어놓는것을 쓰레드라고 함
  - 여러개의 쓰레드는 각각을 제어함
  - 리소스는 프로세스안의 자원을 서로 공유합니다. 
- 쓰레드는  프로세서를 활용하는 기본 단위입니다.
  - CPU 를 활용하는 기본 단위가 됩니다. 
- 구성요소 
  - Thread ID
  - Register Set
  - Stack

> ## Single Thread 

- 제어 요소가 하나 (쓰레드가 하나) 이면 Single Thread , 여러개이면 Multi Thread

> ## 쓰레드의 장점

- 사용자 응답성
  - 일부 스레드의 처리가 지연되어도 다른 스레드는 작업을 계속 처리 가능
- 자원 공유
  - 자원을 공유해서 효율성이 증가 
  - 여러개의 프로세스로 분할되어서 작업되면 Context switch 작업이 필요하여 시간을 많이 잡아먹음
  - 여러개의 쓰레드로 분할되어 (이때 쓰레드들은 하나의 프로세스에 위치) 작업되면 Context witch 는 발생하지 않아서 훨씬 효율적
- 경제성 
  - 프로세스 생성 , context witch 를 하지 않아 효율적
- 멀티 프로세서 활용
  - 병렬처리를 통해서 성능 향상

> ## 예시

![png](/assets/images/Program/16_2.png)

- 우리가 FPS 게임을 한다고 합시다. 

> Single Thread 인 경우

- 화면출력 작업을 하고 있는데 적이 나타남!
- 마우스를 돌리는 순간, 마우스 작업을 하기 위해서 화면출력이 멈춤
- 마우스를 돌리는 작업을 완료하고 나서야 화면 출력이 다시 실행됨

> Multi Thread 인 경우

- 스레드를 세개 만들어서 각각이 화면출력 / 사용자입역 / 스피커 3개를 실행하게 합시다.
- 그러면 각각의 작업을 하면 서로가 멈출 필요가 없고 병렬적으로 일어나서 사용성이 올라갑니다.

> ## 쓰레드의 구현 : 사용자 수준 스레드

![png](/assets/images/Program/17_1.png)

- 사용자 영역의 스레드 라이브러리로 구현됨
  - Win32 Threads , java Threads .... 
- 어떤 사용자가 프로세스를 만든다면, 당연히 커널은 프로세를 제어하기 위해서 쓰레드를 만들게 됩니다. 
  - 당연함! 지금은 프로세스가 하나이므로 하나를 만듭니다.
  - 이때 라이브러리를 이용하여, 여러개의 스레드를 사용하는것처럼 사용자 수준 스레드를 만들어 냅니다.
  - 이때 스레드 라이브러리가, 관리를 하게 됩니다.

- 커널은 스레드의 존재를 모르기 때문에 다음과 같은 특징을 지닙니다.

> 커널의 관리(개입) 을 받지 않음 

- 개입이 없으므로 생성 및 관리의 부하가 적음
- 라이브러리만 바꿔낄수 있으므로 이식성이 높음

> 커널은 프로세스 단위로 자원 할당 (스레드의 존재를 모르니까..)

- A 라는 일을 하는데, 라이브러리가 $A_1, A_2 ,A_3$ 으로, 사용자 수준 스레드를 분리하여 관리하려고 한다고 합시다.
- 하지만 이때, $A_1$ 스레드가 I/O 가 필요하여 $rinning \to asleep \to blcok$ 처리가 되었다고 합시다. 하지만 이떄 3개($A_1, A_2 ,A_3$) 는 모두 모두 덩어리(프로세스) 로 묶여있으므로, 3개의 스레드 모두 블락처리가 됩니다.
  - 즉 단점이라 할 수 있습니다.

> ## 쓰레드의 구현 : 커널 수준 쓰레드

![png](/assets/images/Program/17_2.png)

- OS(kernel) 가 직접 스레드를 관리
  - 스레드이기는 하지만, 서로 하나의 프로세서(CPU)를 사용하기 위해서 서로 Context switch 를 해야됨
  - 즏 커널 영역에 스레드의 생성, 관리를 수행하다 보니까 Context Switch 등 부하(Overhead) 가 큼.
- 프로세스를 실행하면, 커널에 1:1 매핑되어 여러 제어 요소가 생기게 됩니다. 
  - 커널 수준에서 스레드가 1:1 이엿, 한쪽이 block 되어도 다른 스레드는 계속 작업이 가능

> ## 혼합형 (n:m) 쓰레드

![png](/assets/images/Program/17_3.png)

- 위와 같이 우리는 다대일(사용자 수준 스레드) 일대일 모델(커널 수준 스레드)을 살펴보았는데 각각은 장단점이 있었습니다. 각각의 장점만 취할 수 없을까요? 이러한 inituition 으로 탄생한 모델이 혼합형쓰레드 입니다. 

- 다대다 $(\mathrm{n}: \mathrm{m})$ 모델

  - $n>m$
  - 혼합형 스레드로서, 사용자 수준의 서레드 여러개와 커널 수준의 스레드여러개를 사용하는 모델

- 커널 스레드는 자신에게 할당된 하나의 사용자 스레드가 block 상태가 되더라도, 다른 스레드를 수행할 수 있습니다.

  

---

**Reference**

- <https://www.youtube.com/watch?v=MJTr37lgaMA&list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&index=6>

