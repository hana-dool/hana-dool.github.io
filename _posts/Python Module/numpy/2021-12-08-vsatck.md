---
title:  "concatenate"
excerpt: "numpy 배열 합치기"
categories:
  - Py_Numpy
last_modified_at: 2021-12-08
toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true

use_math: true
---

> ## Conatenate 1 Dim

- Concatenate 메소드는 선택한 축의 방향으로 배열을 연결해주는 메서드입니다.

```python
import numpy as np

A1=np.array([1,2,3])
B1=np.array([4,5,6])

np.concatenate([A1,B1])
```

```
array([1, 2, 3, 4, 5, 6])
```

- 위와 같이 두개의 array 를 합치게 된다면, 하나의 array 가 됩니다.
- 1차원에서 axis=0 는 행방향이나 열방향이라는 개념이 없습니다. 
  - 행,열 방향은 행렬부터 의미가 있습니다.

```
1 2 3 (연결) 4 5 6
```

```
1
2
3
(연결)
4
5
6
```

- 위처럼 어떤 연결 (행방향이던 열방향이던) 을 하더라도 결국 `[1,2,3,4,5,6]` 의 벡터가 형성됩니다.

```python
np.concatenate((A1,B1),axis=1)
```

```
AxisError: axis 1 is out of bounds for array of dimension 1
```

- 애초에 위와 같이 1차원에서는 axis = 0 하나뿐이기 때문에 (직선에서는 방향이 하나) axis = 1 은 정의가 되지 않으므로 위는 에러가 뜨게 됩니다.

> ## Concatenate 2D

```python
A2=np.array([ [1,2,3],[10,20,30] ])
B2=np.array([ [4,5,6],[40,50,60] ])
```

- 위와 같이 2개의 Array 를 정의해 보겟습니다.

```
>>> A2
array([[ 1,  2,  3],
       [10, 20, 30]])
>>> B2
array([[ 4,  5,  6],
       [40, 50, 60]])
```

- 이떄 두개의 Axis 는 아래 그림과 같이 구분됩니다.

![jpg](/assets/images/Program/48_1.jpg)

- 0 : row 방향으로 연산이 일어남
- 1 : col 방샹으로 연산이 일어남

```python
np.concatenate((A2,B2),axis=0)
#array([[ 1,  2,  3],
#       [10, 20, 30],
#       [ 4,  5,  6],
#       [40, 50, 60]])
```

```python
np.concatenate((A2,B2),axis=1)
#array([[ 1,  2,  3,  4,  5,  6],
#       [10, 20, 30, 40, 50, 60]])
```

- 위처럼 각각의 axis 가 연산되는 방향으로 데이터가 붙게 됩니다.

> ## Concatenate 3D

```python
A3=np.array([ [[1,2,3,4],[10,20,30,40]], [[100,200,300,400],[10000,2000,3000,4000]] ])

B3=np.array([ [[5,6,7,8],[50,60,70,80]], [[500,600,700,800],[5000,6000,7000,8000]] ])
```

- 위와 같이 정의되었다고 합시다.

```
>>> A3
array([[[    1,     2,     3,     4],
        [   10,    20,    30,    40]],

       [[  100,   200,   300,   400],
        [10000,  2000,  3000,  4000]]])

>>> B3
array([[[   5,    6,    7,    8],
        [  50,   60,   70,   80]],

       [[ 500,  600,  700,  800],
        [5000, 6000, 7000, 8000]]])
```

> Axis = 0

```python
arr = np.concatenate((A3,B3),axis=0)
```

```
array([[[    1,     2,     3,     4],
        [   10,    20,    30,    40]],

       [[  100,   200,   300,   400],
        [10000,  2000,  3000,  4000]],

       [[    5,     6,     7,     8],
        [   50,    60,    70,    80]],

       [[  500,   600,   700,   800],
        [ 5000,  6000,  7000,  8000]]])
```

```
arr.shape
(4,2,4)
```

> Axis = 1

```python
np.concatenate((A3,B3),axis=1)
```

```
array([[[    1,     2,     3,     4],
        [   10,    20,    30,    40],
        [    5,     6,     7,     8],
        [   50,    60,    70,    80]],

       [[  100,   200,   300,   400],
        [10000,  2000,  3000,  4000],
        [  500,   600,   700,   800],
        [ 5000,  6000,  7000,  8000]]])
```

```
arr.shape
(2,4,4)
```

> Axis = 2 

```
arr = np.concatenate((A3,B3),axis=2)
arr
```

```
array([[[    1,     2,     3,     4,     5,     6,     7,     8],
        [   10,    20,    30,    40,    50,    60,    70,    80]],

       [[  100,   200,   300,   400,   500,   600,   700,   800],
        [10000,  2000,  3000,  4000,  5000,  6000,  7000,  8000]]])
```

```
arr.shape
(2,2,8)
```

> Note

- 이제 위처럼 3차, 4차... 로 갈수록 행 , 열 의 구분이 어려워 지는데요, 이때에 위와 같이 정의할 수 있습니다.
  - Axis = 0 : 가장 바깥쪽 (왼쪽) dim 에 붙음
  - Axis = 1 : 중간 dim 에 붙음
  - Axis = 2 : 가장 안쪽 dim 에 붙음
- 위를 적용하면 2D 에서도 외 0 이 row 인지 알 수 있습니다. 
  - 가장 바깥쪽으로 Array 가 붙게된다면, 제일 안쪽의 데이터는 바뀌지 않고, row 가 늘어나야 하기 때문입니다.

 

