---
title:  "Graph 및 서로소집합"
excerpt: "그래프 이론 및 서로소 집합"
categories:
  - AL_Graph_Tree
tags:
  - 1
last_modified_at: 2021-07-10

toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true

use_math: true
---

<br>

# 그래프 알고리즘

- 그래프란 노드와 노드사이에 연결된 간선의 정보를 가지고 있는 자료구조이다
- 알고리즘문제를 접할때에, 여러개의 노드들이 연결되더있고, 간선의 정보가 주어져있다면 그래프 알고리즘을 생각하는게 좋다.
- 그래프와 트리 알고리즘을 비교한다면 아래와 같다. 

|                     | 그래프                | 트리             |
| ------------------- | --------------------- | ---------------- |
| 방향성              | 방향, 무방향 그래프   | 방향 그래프      |
| 순환성              | 순환 및 비순환        | 비순환           |
| 루트 노드 존재 여부 | 루트 노드가 없음      | 루트 노드가 존재 |
| 노드간 관계성       | 부모와 자식 관계 없음 | 부모와 자식 관계 |
| 모델의 종류         | 네트워크 모델         | 계층 모델        |

- 그래프의 구현 방법은 2가지가 존재한다. 

> 인접 행렬 : 2차원 배열을 이용하는 방식
>
> 인접 리스트 : 리스트를 사용하는 방식

- 2가지 방식 모두 그래프 알고리즘에서 많이 사용된다. 두 방식은 메모리, 속도 측면에서 특징을 가진다.
- 노드의 개수가 V , 간선의 갯수가 E 개인 그래프를 생각해보자. 

|        | 그래프   | 트리   |
| ------ | -------- | ------ |
| 메모리 | $O(V^2)$ | $O(E)$ |

- 위와 같은 메모리를 잘 고려하면서 알고리즘을 짜야할 것이다.
- 최단경로를 구해야할 떄에, 노드의 갯수가 적은 경우에는 플로이드 워셜이 가능하다.
- 노드 , 간선의 갯수가 매우 많다면 다익스트라 알고리즘을 활용할 수 있다. 

<br>

# 서로소 집합

![png](/assets/images/Python/19_1.png)

- 서로소 집합은 위와 같이, 서로 겹치는 원소가 없는 집합을 의미합니다. 

![png](/assets/images/Python/19_2.png)

- 위와 같이 서로소 집합 자료구조는, 두 종류의 연산을 지원합니다.

![png](/assets/images/Python/19_3.png)

![png](/assets/images/Python/19_4.png)

- 초기 단계에서는, 각자의 집합은 자기 자신을 노드로 가집니다.

![png](/assets/images/Python/19_5.png)

- 작은것을 루트로 가지도록 사용합니다. (물론 큰것을 루트로 할 수도 있습니다.)

![png](/assets/images/Python/19_6.png)

![png](/assets/images/Python/19_7.png)

- '부모가 다르다는것은' 다른 집합임을 알 수 있습니다. 

![png](/assets/images/Python/19_8.png)

![png](/assets/images/Python/19_9.png)

- 위처럼 연결을 다 끝내고 나면, 연결성을 통해 총 몇개의 그룹이 존재하는지를 알 수 있습니다.

```python
# 특정 원소가 속한 집합 찾기 (경로압축)
def find_parent(parent,x) :
    # parent 에 '연결된 루트' 가 아니라 '제일 깊은 부모' 를 출력함으로서 시간단축
    # 연결된 루트만 표시하면 지렁이 줄줄이로 시간이 엄청 걸릴수도 있다.
    if parent[x] != x : 
        parent[x] = find_parent(parent,parent[x])
    return x 

# 두 원소가 속한 집합 합치기
def union_parent(parent,a,b):
    a = find_parent(parent,a)
    b = find_parent(parent,b)
    if a<b :
        parent[b] = a
    else :
        parent[a] = b 

# 노드의 갯수와 간선(union 연산) 의 갯수 입력
v,e = map(int,input().split())
parent = [0] * (v+1)
for i in range(e) : 
    a,b = map(int,input().split())
    union_parent(parent,a,b) 
    
# 각 원소가 속한 집합 출력 
for i in range(1,v+1) :
    print(find_parent(parent,i),end=' ') 
    
# 부모 테이블 내용 출력
# 단순히 부모테이블 내용일 뿐. (연산을 수행하고 나서는, )
print(parent)
```





<br>
