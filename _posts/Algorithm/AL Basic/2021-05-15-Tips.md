---
title:  "6.Tip"
excerpt: "팁팁"
categories:
  - AL_Basic
tags:
  - 1
last_modified_at: 2021-07-04

toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true

use_math: true
---

<br>

# 데이터 Sapping

- 다음과 같이 하게 되면, a,b 값이 바뀌게 된다.

```python
a = 1 , b = 2
a,b = b,a #a=2,b=1 이됨
```

- 위와같이 하게 된다면 a 와  b 의 값이 바뀌게된다. 

```
a[i],a[j] = a[j],a[i] # 옆과 같이 list 에도 적용할 수 있다. 
```

<br>

# 갯수가 정해지지 않은 Input

- input 의 갯수가 정해지지 않고 계속 들어온다면 언제 멈추어야 할까? 

```python
while True : 
    a = input()
    if not a :
        break
```

- 위와 같이, '아무것도 받지 못한다면'  Break 하는 형식으로 구현 가능하다!

<br>

# 재귀제한

```
import sys
sys.setrecursionlimit(1000000000)
```

- 만약 재귀를 사용해서 풀어야 하는 문제라면, 위 코드를 상단에 쓰는 것은 선택이 아닌 필수이다. 파이썬의 기본 재귀 깊이 제한은 1000으로 매우 얕은 편이기 떄문! 

- 근데 중요한게 sys.setrecursionlimit(10**10) 처럼 하면 안된다고 한다.. sys 가 시스템 언어여서 c 의 int 자료형만을 받아야하는데 위는 그게 되지 않는듯 하다! 

<br>

# 파이썬에서의 리스트 크기

- 대체로 코딩테스트에서는 128 ~ 512 MB 의 메모리가 제한이 있다. 
- 이러한 경우 수백만개 이상의 데이터를 처리해야 할 때가 있다. 

| 데이터의 갯수(리스트의 길이) | 메모리 사용량 |
| ---------------------------- | ------------- |
| 1000(천)                     | 4KB           |
| 1000000(십만)                | 4MB           |
| 10000000(백만)               | 40MB          |

- 즉 위와 같이 데이터의 갯수가 천만개 이상의 리스트를 생성한다면 메모리 제한에 걸릴것이다. 
- 하지만 크게 고민하지 않아도 되는것이, 일반적인 코테 수준에서는 메모리 사용량 제한보다 더 적은 데이터만 사용하면 된다는것을 기억하자. 

## Matrix 

- 일반적으로 Matrix 를 만들게 된다면 정점의 수 N 에 따라, 그 크기가 $N^2$ 이 된다는 것을 명심하자.
-  즉 , 정점의 수가 만개가 넘으면 메모리 초과가 날 것이다.
  - 이는 matrix 로 경로들을 구현할때에 자주 보이는데, 정점은 몇개 없지만 그 값의 범위가 10000이 넘는다면 매트릭스로 구현시에는 어쩔 수 없이 엄청 큰 메트릭을 만들게 되어서 메모리 초과가 날 수 있다.



 <br>

# 시간 제한

- 온라인 서비스에서 시간 제한은 1~2초인 경우가 많다.
- 2020년 기준 파이썬 3.7 코드 작성시 1초에 2000만 정도로 잡으면 안정적이라 한다. 
  - 즉 만약 시간 제한이 1초이고 데이터 갯수가 100만이라면 복잡도는 NlogN 이하여야 할 것이다.

<br>

# PYPY3

- pypy3 은 파이썬으로 파이썬을 만드는 프로젝트이다. 그런데 파이썬으로 파이썬을 만든다는것은 말도 안되보이는데 어떻게 만들까? 
  - 1.먼저 파이썬 문법을 엄격하게 만들어 컴파일이 되게 만든 해석기 (Translate.py) 를 파이썬 코드로 작성한다. 
  - 2.RPython의 효과적인 컴파일을 위해 다른 언어로 툴체인을 만든다.
  - 3.Python 구현(런타임)을 RPython 문법으로 작성한다.
  - 3에서 만든 구현을 1 또는 2에서 만든 RPython 해석기로 컴파일한다.
  - 4으로 만든 후보를 이전 또는 다른 구현과 비교(성능 측정), 만족스럽지 않으면 수정한다.
  - 5에서 만족스러운 결과를 냈다면 출시하고 1 또는 2부터 다시 시작한다.(release)
- pypy3 은 파이썬 3의 문법을 그대로 지원한다.
- 하지만 대부분 파이썬 3보다 실행 속도가 빠르다. 

- 이런 식으로 어떤 언어로 자기 자신을 구현하는 것을 **부트스트래핑**(Bootstrapping) 또는 **부팅**(Booting)이라고 한다,
- 이렇게 하는 이유는 처음부터 작업하는 것보다 생산성이 좋기 때문이다.
- 말이 길었지만, 어쩃든 pypy 는 모든 파이썬 문법을 지원하며 또한 빠르기 때문에 코딩테스트에서 pypy3 을 선택할 수 있다면, 이를 선택하도록 하자. 

<br>

# 인덱싱

- a번쨰부터 b 번째라고 하면 , x[a-1:b] 이다. 
- 인덱싱의 범위가 벗어나도 출력된다. 

```python
s = 'abc'
s[1:5] # 'bc'
```

<br>

# Name Space 범위

- 프로그래머스에서 문제를 풀다보면 

```python
def solution(numbers, target):
    cnt = 0 
    def dfs(depth,cnt) :
        global ans
        if ... 
        	cnt += 1 
```

- 위와 같이 DFS를 짤떄에 DFS 를 Global 로 취하여 밖에서 참조하고 싶을 수 있다. 
- 하지만 위의 경우는 이미, cnt 가 solution 이라는 함수 안에 들어있으므로 전역번수(global) 이 아니다. 
- 즉 cnt 를 제일 밖으로 뺴주어야한다. 

```python
cnt = 0 
def solution(numbers, target):
    def dfs(depth,cnt) :
        global ans
        if ... 
        	cnt += 1 
```

<br>

# 제곱수 체크

```python
# x가 제곱수인지 아닌지 체크하는법
int(x**0.5) == x**0.5 
```

- 약수의 갯수가 홀수개인것을 이용하는건 매우 힘드므로 위와 같이 구현할 수 있다.
