---
title:  "6.Tip"
excerpt: "팁팁"
categories:
  - AL_Basic
tags:
  - 1
last_modified_at: 2021-07-04

toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true

use_math: true
---

<br>

# 데이터 Sapping

- 다음과 같이 하게 되면, a,b 값이 바뀌게 된다.

```python
a = 1 , b = 2
a,b = b,a #a=2,b=1 이됨
```

- 위와같이 하게 된다면 a 와  b 의 값이 바뀌게된다. 

```
a[i],a[j] = a[j],a[i] # 옆과 같이 list 에도 적용할 수 있다. 
```

<br>

# 갯수가 정해지지 않은 Input

- input 의 갯수가 정해지지 않고 계속 들어온다면 언제 멈추어야 할까? 

```python
while True : 
    a = input()
    if not a :
        break
```

- 위와 같이, '아무것도 받지 못한다면'  Break 하는 형식으로 구현 가능하다!

<br>

# 재귀제한

```
import sys
sys.setrecursionlimit(1000000000)
```

- 만약 재귀를 사용해서 풀어야 하는 문제라면, 위 코드를 상단에 쓰는 것은 선택이 아닌 필수이다. 파이썬의 기본 재귀 깊이 제한은 1000으로 매우 얕은 편이기 떄문! 

- 근데 중요한게 sys.setrecursionlimit(10**10) 처럼 하면 안된다고 한다.. sys 가 시스템 언어여서 c 의 int 자료형만을 받아야하는데 위는 그게 되지 않는듯 하다! 

<br>

# 파이썬에서의 리스트 크기

- 대체로 코딩테스트에서는 128 ~ 512 MB 의 메모리가 제한이 있다. 
- 이러한 경우 수백만개 이상의 데이터를 처리해야 할 때가 있다. 

| 데이터의 갯수(리스트의 길이) | 메모리 사용량 |
| ---------------------------- | ------------- |
| 1000(천)                     | 4KB           |
| 1000000(십만)                | 4MB           |
| 10000000(백만)               | 40MB          |

- 즉 위와 같이 데이터의 갯수가 천만개 이상의 리스트를 생성한다면 메모리 제한에 걸릴것이다. 
- 하지만 크게 고민하지 않아도 되는것이, 일반적인 코테 수준에서는 메모리 사용량 제한보다 더 적은 데이터만 사용하면 된다는것을 기억하자. 

## Matrix 

- 일반적으로 Matrix 를 만들게 된다면 정점의 수 N 에 따라, 그 크기가 $N^2$ 이 된다는 것을 명심하자.
-  즉 , 정점의 수가 만개가 넘으면 메모리 초과가 날 것이다.
  - 이는 matrix 로 경로들을 구현할때에 자주 보이는데, 정점은 몇개 없지만 그 값의 범위가 10000이 넘는다면 매트릭스로 구현시에는 어쩔 수 없이 엄청 큰 메트릭을 만들게 되어서 메모리 초과가 날 수 있다.



 <br>

# 시간 제한

- 온라인 서비스에서 시간 제한은 1~2초인 경우가 많다.
- 2020년 기준 파이썬 3.7 코드 작성시 1초에 2000만 정도로 잡으면 안정적이라 한다. 
  - 즉 만약 시간 제한이 1초이고 데이터 갯수가 100만이라면 복잡도는 NlogN 이하여야 할 것이다.

<br>

# PYPY3

- pypy3 은 파이썬으로 파이썬을 만드는 프로젝트이다. 그런데 파이썬으로 파이썬을 만든다는것은 말도 안되보이는데 어떻게 만들까? 
  - 1.먼저 파이썬 문법을 엄격하게 만들어 컴파일이 되게 만든 해석기 (Translate.py) 를 파이썬 코드로 작성한다. 
  - 2.RPython의 효과적인 컴파일을 위해 다른 언어로 툴체인을 만든다.
  - 3.Python 구현(런타임)을 RPython 문법으로 작성한다.
  - 3에서 만든 구현을 1 또는 2에서 만든 RPython 해석기로 컴파일한다.
  - 4으로 만든 후보를 이전 또는 다른 구현과 비교(성능 측정), 만족스럽지 않으면 수정한다.
  - 5에서 만족스러운 결과를 냈다면 출시하고 1 또는 2부터 다시 시작한다.(release)
- pypy3 은 파이썬 3의 문법을 그대로 지원한다.
- 하지만 대부분 파이썬 3보다 실행 속도가 빠르다. 

- 이런 식으로 어떤 언어로 자기 자신을 구현하는 것을 **부트스트래핑**(Bootstrapping) 또는 **부팅**(Booting)이라고 한다,
- 이렇게 하는 이유는 처음부터 작업하는 것보다 생산성이 좋기 때문이다.
- 말이 길었지만, 어쩃든 pypy 는 모든 파이썬 문법을 지원하며 또한 빠르기 때문에 코딩테스트에서 pypy3 을 선택할 수 있다면, 이를 선택하도록 하자. 

<br>

# 인덱싱

- a번쨰부터 b 번째라고 하면 , x[a-1:b] 이다. 
- 인덱싱의 범위가 벗어나도 출력된다. 

```python
s = 'abc'
s[1:5] # 'bc'
```

<br>

# Name Space 범위

- 프로그래머스에서 문제를 풀다보면 

```python
def solution(numbers, target):
    cnt = 0 
    def dfs(depth,cnt) :
        global ans
        if ... 
        	cnt += 1 
```

- 위와 같이 DFS를 짤떄에 DFS 를 Global 로 취하여 밖에서 참조하고 싶을 수 있다. 
- 하지만 위의 경우는 이미, cnt 가 solution 이라는 함수 안에 들어있으므로 전역번수(global) 이 아니다. 
- 즉 cnt 를 제일 밖으로 뺴주어야한다. 

```python
cnt = 0 
def solution(numbers, target):
    def dfs(depth,cnt) :
        global ans
        if ... 
        	cnt += 1 
```

<br>

# 제곱수 체크

```python
# x가 제곱수인지 아닌지 체크하는법
int(x**0.5) == x**0.5 
```

- 약수의 갯수가 홀수개인것을 이용하는건 매우 힘드므로 위와 같이 구현할 수 있다.

<br>

# 뒤집었을떄의 규칙

```python
# Reverse 시켰을때의 index 는 x -> n-1-x
[1,3,2,5] -> [5,2,3,1]    
# 3 의 idx 는 1 -> 2
```

- 위와 같이 Reverse 를 할때의 규칙은 알아두는것이 좋다.

<br>

# 격자에서 대각선의 규칙

- 왼쪽 상단에서 아래쪽으로의 대각선은  

```python
for i in range(n):
    mat[i][i]
```

- 왼쪽 하단에서 오른쪽 상단의 대각선은

```python
for i in range(n) : 
    mat[i][n-1-i]
```

<br>

# 역으로 내려가는 range

```python
for i in range(n) :
    print(i) # 0,1,2,.... n-1 
    
for i in range(n)[::-1] :
    print(i) # n-1..... 0 
```

- 위와 같이 range 옆에 ::-1 을 넣으면 역수가 됩니다.
- 물론 range(n-1,-1,-1) 로 하면 위와 같이 할 수 있지만 이는 직관적이지 못하다..

<br>

# range(i) 에서의 변수이름

```python
for i in range(n) : # row
    for j in range(m) : # col
        if matrix[i][j] == 'M' :
            now = (i,j)
            break
```

- 위에서의 경우와 

```python
for i in range(n) : # row
    for j in range(m) : # col
        if matrix[i][j] == 'M' :
            break 
now = (i,j)
```

- 이 경우는 다릅니다. 
- break 가 한겹밖에 없어서, i,j 가 ==M 일떄에 멈추지 않습니다.
- 그러므로 아래처럼 할꺼면 이중 break 문을 쓰거나 혹은 맨 위처럼 해야합니다.

<br>

# Integer Input

- input 에 100000 자리의 자연수가 들어온다고 합시다.

```python
int(input()) # 시간이 오래걸림
input() # 시간이 조금 걸림
```

- 이 경우에 , 그정도 수를 문자열형에서 정수 자료형으로 바꾸는데 많은 시간이 걸립니다.
- 또한 메모리 공간도 많이 차지하고 이만한 공간을 새로 확보하는데 추가로 시간이 듭니다.

https://www.acmicpc.net/problem/1769

- 위 문제에서 input 을 int 로 바꿔서 받으면 시간초과로 통과하지 못합니다.
