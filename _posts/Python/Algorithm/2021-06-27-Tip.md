---
title:  "자료형 Tip"
excerpt: "dict List String.."
categories:
  - Py_Algorithm
tags:
  - 1
last_modified_at: 2021-06-26

toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true

use_math: true
---

<br>

# <center><font size="15">1. List</font></center>

- List 는 의외로 많이 쓰이는 자료형이다.
- pred = [] 로 정의 후 뒤의 for 문에서 c.v. 로 계산한 predict 값을 pred 에 concat 해서 채워 넣는등 많이 쓰임

## 기본성질

- indexing
  - x[a] : a 번째 element
  - x[a : b] : a~b-1 까지의 리스트값 출력
  - x[a​ : : ​k] : k 씩 간격을 두면서 a~b-1 까지의 list 값 출력
  - x[b​ : a : ​-1] : b 부터 a+1 까지 역순으로 리스트값 출력
    - ex) [1,2,3,4,5][5:1:-1] 은 [5,4,3,2] 이다.
    - ex) [1,2,3,4,5][5:-1:-1] 은 [5,4,3,2,1] 이 아니라 에러가 난다.
  - x [a] [b] : a 번째 element 의 b번째 element
    - ex) $[[1,2],[3,4]][1] = [1,2]$

<br>

## 메소드

- +*

  - \+ : 리스트 concat
  - \* : 리스트 반복

- .len( )**: list의 길이

- .append()

  : list 맨 뒤에 element 추가

  - 이 떄에 x = x.append(i) 로 하면 안된다.
  - x.append(i) 를 하면 x 에 inplace 하게 추가가 된다.
  - inplace

- .extend()

  : list 맨 뒤에 iterable 객체 elemenet 추가

  - 이 때 x.append([1,2]) 를 하게되면 x 의 맨 뒤에 element 가 추가된다.
  - inplace

- .insert (위치,데이터)

  : 리스트의 위치에 데이터 추가

  - inplace

- .sort ( )

  : list 를 sorting 해준다.

  - inplace 한 연산이다.
  - key 를 지정하게되면, 그 위치를 기준으로 정렬하게 된다.
    - [[3,4],[2,1],[1,3]].sort(key = lambda x : x[0]) -> [[1,3],[2,1],[3,4]]
    - [[3,4],[2,1],[1,3]].sort(key = lambda x : x[1]) -> [[2,1],[1,3],[3,4]]
  - key 를 다중으로 지정하게되면, 여러 기준을 통해서 정렬하게 된다.
    - [[3,4],[1,1],[1,3],[3,2]].sort(key = lambda x : (x[0],x[1])) -> [[1,1],[1,3],[3,2],[3,4]] # 첫번째 값 기준으로 정렬 후, 두번째 값 기준으로 정렬

- .reverse ( )

  : list 를 역방향으로 sorting

  - inplace

- .index ( x )

  : x의 위치를 반환.

  - 처음으로 만나는 x 의 위치를 반환한다.
  - 없으면 에러를 발생시킨다.

- .insert ( a, b )

  : a번째 위치에 b를 삽입

  - inplace

- .remove ( x )

   

  : 첫번째로 나오는 x를 삭제

  - inplace

- .pop ( )

  : list의 맨 마지막 element 출력 이후 삭제

  - 이때 맨 마지막 element가 나온 이후 삭제가 inplace 하게 이루어진다.
  - pop( a ): a 번쨰 element 를 pop 한 이후 삭제
  - inplace
  - [Examlple]
    - val = [1,3,2].pop() -> 리스트는 [1,3] 이 되고, val 은 2 가 된다.

- **.count ( x )**: list 안에 x가 몇 개 있는지 조사해서 그 개수를 반환

<br>

## 주의점 

- 리스트는 연산을 하지 못한다. ([1,2,3] + 3 은 에러가남 )
- 리스트끼리 연산이 된다 해도, 그건 concat 이다. ([1,2,3] + [1,2] = [1,2,3,1,2])
- 대부분의 연산이 inplace 하게 일어나기 때문에 lis = lis.sort() 같은 연산을 하면 안된다.
- 비어있는 list 에 인덱스를 이용해 추가하는 연산은 불가능
  - 즉 lis = [] 에 대해 lis[1] = 2 는 에러가 남

<br>

## Tip

- if x in [a,b,..]
  - 'x 가 [] 안에 있는 값을 가진다면' 의 의미를 가진다.
- list(enumerate(['딸기','사과','포토']))
  - [(0,'딸기'),....(2,'포도')] 처럼 list 가 생성이 된다.
- list('abc')
  - ['a','b','c'] 처럼 분해가 된다
- list(set(list('word')))
  - word 를 'unique 한 값들의 list 로 변환시켜준다.
- append 와 += 의 차이
  - append 는 inplace 하게 연산되어서 id 가 바뀌지 않는다.
  - \+ 는 L += [4] 의 경우 L = L + [4] 와 같고, 이는 L+[4] 라는 새로운 LIST 를 만든 뒤에 L 에 할당되어서 id 가 바뀐다.
  - def 와 사용하게 될 때에 += 를 사용하게 되면 L = L+[4] 에서 왼쪽의 L 을 local 변수로 인식하기 떄문에 주의해야한다
- \* 와 주소
  - element 가 list 이라면, * 로 element 를 생성한다면 동일 id 를 공유하게 된다.
  - [x]*3 을 하게 되면 [x, x, x] 가 나오고 x 는 모두 같은 id 를 공유
  - 즉 lis = [[]]*4 를 한 뒤, lis[1].append(1) 을 하면 [[1],[1],[1],[1]] 로 4개가 전부 바뀌어버린다.
  - 즉 [[] for _ in range(3)] 으로 해주는게안전
- List comprehension
  - 일반적으로 for 문으로 받는것보다, List comprehension 이 더 빠르다고 한다.
  - [ input() for _ in range(N)] 이 for _ in range(N): lst.append(input()) 보다 빠르다는것!
- 같은값 복사
  - lis = [k.copy() for _ in range(10)] 와 같은 형식으로 진행해야, lis 안의 list 들이 k 와 다른 주소값을 가져서,각기 다르게 변경이 가능하다.
  - lis = [k for _ in range(10)] 을 하게된다면, 원소들이 모두 같은 값을 가르키게 되어서 안된다.
- [1,4,3] -> 143
  - val = [str(x) for x in val]
  - ans = ''.join(val)
- 리스트 0 이상 값 갯수세기
  - sum([1 for i in lis if i > 0 ])

<br>

<br>

---

---

# <center><font size="15">2. Dict</font></center>

---

---

- 사람은 누구든지 "이름" = "홍길동", "생일" = "몇 월 며칠" 등으로 구별할 수 있다.
- 이런 대응관계를  요즘 사용하는 대부분의 언어도 이러한 대응 관계를 나타내는 자료형을 갖고 있는데, 이를 연관 배열(Associative array) 또는 해시(Hash)라고 한다
- 파이썬에서는 위의 대응관계를 나타내는것을 dictionary 라고 한다. Key와 Value를 한 쌍으로 갖는 자료형이다. 
- 딕셔너리는 리스트나 튜플처럼 순차적으로(sequential) 해당 요솟값을 구하지 않고 Key를 통해 Value를 얻는다.
- Key 는 변하지 않는(immutable) 자료형이 key 로 가능하다. (Value 는 다가능..)
- Iterable이며 순서가 보장되는 자료형이다. 따라서 인덱싱과 슬라이싱, 합과 곱 연산이 가능합니다.

<br>

## 기본 성질

- **indexing**
    - x['a'] : key a 에 해당하는 value 를 출력
    - x[3] : 이는 에러가 난다. 위치에 따른 indexing 은 불가능
    - x[3:5] : 이 역시 에러가 난다. slicing 또한 불가능
- **len()** : 사전의 길이 출력
    - 이때, 길이는 key 의 수가 된다.
- **.keys ( )**: key 를 가지는 배열 만들기
    - list 도 얻고싶다면 list(...keys()) 로 한번 더 덛씌워야 한다.
- **.values ( )**: value를 list로 만들기
    - 이 역시 위와 같음
- **.items ( )**: key, value의 tuple 반한
    - [(key,value)...] 꼴로 반환하게 된다.    
- **.get ( x , '디폴트')**
    - x에 해당하는 key 에 대해 vlaue 값을 출력한다.
    - x에 해당하는 key 값이 없을 때 디폴트 값을 출력한다.
- **in**: 해당 key가 있는지 조사

<br>

## Sorting

**dict의 sorting**

- **key sorting**
    - sorted(dic.items()) # dictionary 를 [(key,value)] 꼴로 나타낸 후 오름차순 정렬한다. 즉 이 값에 다시 dict 를 붙여주면 key 를 기준으로 sorting ,된 dictionary 가 나옴
    - sorted(dic.items(),reverse=True ) 를 통해서 내림차순도 가능하다.    
- **value sorting**
    - sorted(dic.items(), key = lambda x : x[1]) # key 를 지정해주면 해당 함수의 반환값을 비교하여 순서대로 정렬한다.
    - sorted(dic.items(), key = lambda x : (x[0],x[1]) ) : key, value 순서로 오름차순 정렬

<br>

## Tip

- dic 의 key, val 값

    - .values() 나 . keys() 로 나온값은 list 가 아니라 그 자체 values, keys 객체이기 떄문에 별로 쓸모가 없다. 바로 list 로 바꿔주어여 한다. 

    - 즉 list(dict.values()) 로 사용하는것이 좋다는 이야기

```python
dic.values()
```

- dict 의 for 문

```python
for x in dic # x 는 key 값을 순회
for x,y in dic.items() # x는 key / y 는 val 을 순회
```

- dict의 변수지정과 업데이트
    - dict[x] += 1 처럼 업데이트가 필요할 때에, x key 가 없는 상태라면 저절로 1로 업데이트 되지 않고 에러가 난다. 
    - 이런 경우를 대비하기 위해서는 dic['x'] = dic.get('x',0) += 1 로, 없는 상태의 경우도 대비하기 위해서 get 으로 가져와야한다

```python
dic = {}
dic[i] = j # {i:j} 생성
dic[i] += j # 빈 값에 j 를 더하는것은 에러가 난다. 
dic[i] = dic.get(i,0) += j # i 값에 j 를 더하되, 없으면 0 
```

- 구현시에 아래와 같이 Zip 과 같이 사용하면 큰 도움이 된다. 

```python
x = [1,2,3,4]
y = ['a','b','c','d']
dict(zip(x,y))
```

<br>

---

---

# <center><font size="15">3. Set</font></center>

---



---

##기본 구조

- 순서가 없고, 집합안에서는 unique한 값을 가진다.
- mutable 객체
- {[1,2,2,2,3]} = {1,2,3}

<br>

## 메서드

- **a in set** : a 가 set 안에 있는지 검사
- **A | B** : A,B set 에 대한 합집합
- **A & B** : A,B set 에 대힌 교집합
- **A - B** : A,B set 에 대한 차집합
- **A ^ B** : A,B set 에 대한 sym_diff
- **.add()** : set 에 원소 추가(하나씩)
    - inplace
- **.update()** : 한번에 여러 원소들을 update 할 때에 사용
    - {1,2}.update([1,4,5]) -> {1,2,4,5}
    - inplace 
- **.remove()** : 원소 제거
    - inplace
- **.issubset** : 부분집합 여부 확인
    - {1,2}.issubset({1,2,4,5}) -> True
- **.isdisjoint** : 두 집합이 겹치지 않으면 True
    - {1,3}.isdisjoint({2,4}) -> True

<br>

## Tip

- 빈 set 을 만들때에는 {} 가 아니라 set() 으로 해주어야한다. {} 는 dict 를 형성하는것임

